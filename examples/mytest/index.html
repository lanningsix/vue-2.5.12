<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .test-children {
      width: 30px;
    }
  </style>
</head>

<body>
  <div id="el">
    {{selected}}
  </div>
  <script src="../../dist/vue.js"></script>
  <script>
    new Vue({
      el: '#el',
      data: {
        selected: 0,
        options: [
          { id: 1, text: 'Hello' },
          { id: 2, text: 'World' }
        ]
      }
    })
  </script>
  <script>

    fetch('http://activity.61info.cn/static/cms/areaData/countryData.json')

    let xhrss = new XMLHttpRequest()
    xhrss.open('get', 'http://activity.61info.cn/static/cms/areaData/countryData.json')
    xhrss.send()
    // function async1() {
    //   console.log('async1 start'); // 1
    //   const p = async2();
    //   return new Promise((resolve) => {
    //     Promise.resolve().then(() => {
    //       p.then(resolve)
    //     })
    //   })
    //     .then(() => {
    //       console.log('async1 end') // 6
    //     });
    // }

    // function async2() {
    //   console.log('async2'); // 2
    //   return Promise.resolve();
    // }

    // async1();

    // new Promise((resolve) => {
    //   console.log(1) // 3
    //   resolve()
    // }).then(() => {
    //   console.log(2) // 4
    // }).then(() => {
    //   console.log(3) // 5
    // }).then(() => {
    //   console.log(4) // 7
    // })

    // async function async1() {
    //   console.log('async1 start')
    //   // await async2()
    //   // console.log('async1 end')
    //   const p = async2()
    //   return Promise.resolve(p)
    //   .then(() => {
    //     console.log('async1 end')
    //   })
    // }

    // function async2() {
    //   console.log('async2')
    //   return Promise.resolve(Promise.resolve().then(() => {
    //     console.log('444')
    //   }))
    // }

    // console.log('script start')

    // setTimeout(function () {
    //   console.log('setTimeout')
    // }, 0)

    // async1();

    // new Promise(function (resolve) {
    //   console.log('promise1')
    //   resolve()
    // }).then(function () {
    //   console.log('promise2')
    // }).then(function () {
    //   console.log('promise3')
    // }).then(function () {
    //   console.log('promise4')
    // })

    // console.log('script end')
    // const a = [123]
    // const newMethods = Object.create(Array.prototype)
    // const original = Array.prototype.push
    // Object.defineProperty(Array.prototype, 'push', {
    //   value: function mutator(...args) {
    //     console.log('🚀 ~ file: index.html ~ line 31 ~ args', args)
    //     return original.call(this, args)
    //   },
    //   enumerable: false,
    //   writable: true,
    //   configurable: true
    // })

    // let a = function () {
    //   console.log(this)
    //   console.log(this.name)
    // }
    // let b = { name: '我是b' }
    // a.bind(b)

    // Object.prototype.bind = function (newObj, ...args) {
    //   const ctx = newObj || window
    //   ctx.fn = this
    //   return function (...argsRemain) {
    //     const result = ctx.fn(...args, ...argsRemain)
    //     delete ctx.fn
    //     return res
    //   }
    // }
    // 首先从对象说起，vue将data初始化为observer 利用Object.defineProperty重写每个对象的每个属性的get, set方法，每一个key都有一个独立的依赖收集器
    // 每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，在get里面收集每一个watcher（渲染watcher， 计算属性watcher, 侦听器watcher），存储在dep中
    // 在set更新的时候通知dep，dep再通知每一个watcher，从而达到更新
    // 响应式数组会重写它的push，slice, pop等7个方法, 在触发的时候，拿到当前的dep，通知更新
    
    // 利用了发布订阅的设计模式
    // 当创建 Vue 实例时,vue 会遍历 data 选项的属性,利用 Object.defineProperty 为属性添加 getter 和 setter 对数据的读取进行劫持（getter 用来依赖收集,setter 用来派发更新），
    // 每个属性有对应的dep实例，在被访问时，会触发data的getter方法，收集依赖于此data的watcher收集到dep.subs队列中
    // 之后依赖项被改动时,setter 方法会通知依赖与此 data 的 watcher 实例重新计算（派发更新）,从而使它关联的组件重新渲染。
  </script>
</body>

</html>